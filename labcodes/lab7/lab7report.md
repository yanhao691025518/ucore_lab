##lab7 report
#####2012011330 闫昊
***
###练习一 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题
> 内核级信号量的设计：

* 当多个进程进行互斥或同步合作时，一个进程会由于无法满足信号量设置的条件而在某一个位置停止。
* semaphore_t就是内核中的信号量，主要包含up和down两个操作

* 具体实现中，就是使用local_intr_save来禁用中断，保证kernel不会被打断，从而实现对结构体的“原子”修改。因为不会被中断，所以不会被抢占，也就不会存在竞争。

* up和down都需要处理等待的问题。down的时候如果发现信号量为0，就加入等待队列，并且调度到其它进程。up则会唤醒等待的进程，如果有的话。

> 信号量操作P函数和V函数实现如下：

* P操作：首先关掉中断，然后判断当前信号量的value是否大于0，如果>0，则获得信号量，故让value减1，并打开中断返回即可。如果不是>0,则无法获得信号量，需要将当前的进程加到等待队列中，打开中断，让调度器选择两一个进程执行，被V唤醒之后，把自身关联的wait从等待队列中删除。

###练习二 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题
> 内核级条件变量的设计描述

* 条件变量包含一个信号量，一个等待的计数器，以及monitor的指针。

* monitor包含一个信号量数组，两个信号量，一个用于锁住monitor，另一个保证wait的进程与signal进程不冲突的衔接。

* 所有操作monitor的调用都要首先获取monitor的锁

* cond_signal检测是否有等待条件变量的进程，如果有的话释放monitor的锁，并试图获取next锁，防止和cond_wait一起操作monitor。

* cond_wait检测是否有等待被唤醒的cond_signal，如果有的话唤醒它，否则释放monitor的锁。此时试图获取条件变量的信号量，从而使得条件满足时函数返回。

> 用户态进程/线程提供条件变量机制

*类似用户态信号量的实现。
