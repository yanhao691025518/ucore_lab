##lab3  report

#####2012011330 闫昊
***

###练习一 给未被映射的地址映射上物理页


>设计实现过程
1. 首先获取缺页地址对应的PTE
2. 如果PTE为空，那么表示这个虚拟内存对应的页不存在，就建立相应的页
3. 否则把页从硬盘中换入到内存里

>页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处:获取虚拟地址对应的物理地址，并且根据标志位判断是否在虚存当中。
***
> 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常:

1. CPU在当前内核栈保存当前被打断的程序现场，即依次压入当前被打断程序使用的EFLAGS，CS，EIP，errorCode
2. 由于页访问异常的中断号是0xE，CPU把异常中断号0xE对应的中断服务例程的地址（vectors.S中的标号vector14处）加载到CS和EIP寄存器中，开始执行中断服务例程
3. ucore开始处理异常中断，首先需要保存硬件没有保存的寄存器
4. 在vectors.S中的标号vector14处先把中断号压入内核栈，然后再在trapentry.S中的标号__alltraps处把DS、ES和其他通用寄存器都压栈。自此，被打断的程序执行现场（context）被保存在内核栈中
5. 在trap.c的trap函数开始了中断服务例程的处理流程

###练习二 补充完成基于FIFO的页面替换算法

>设计实现

1. 首先是填充do_pgfault函数，调用swap_in函数，把数据swap进来，然后是做标记

2. 然后是填充swap_fifo.c的map_swappable和swap_out_victim
map_swappable就是把页面加入swappable的队列
3. swap_out_victim就是把队列的队尾的page拿出来，在队列中删除，返回页面

#####如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架足以支持在ucore中实现此算法

1. 插入的时候方法类似，插入到队尾。需要换出时，记录四个指针，表示4种修改、访问组合，初始全为NULL。扫描一遍链表，选出最应该换出的指针即可，实际上如果碰到了（0，0）这种，可以停止扫描直接退出。

2. 可以通过PTE上的标志位判断

3. 当发生Page Fault的时候会进行换入，内存占满需要换入时则需要先换出。